<?php 

class CWordXML {
    /*
    *	List of fonts to be used in the document
    *	Default set to Arial
    */
    public $_fonts			= array();
    /*
    *	Definition of lists to be used in the document
    *	DefaultListDef used for default title styles
    */
    public	$_listDef		= array();
    /*
    *	Definition of styles to be used in the document
    *
    */
    public $_styles		= array();
    /*
    *	Document Properties
    *	Contains the standard document properties (title, author, etc...)
    */
    public $_docProperties	= array();
    /*
    *	Doc Properties array
    *	Contains information relative to the document layout
    */
    public $_docPr			= array();
    /*
    *	Section Properties array
    *	Contains information on sections (header, footer, page size, orientation)
    */
    public $_sectPr		= array();
    /*
    *	Current section number
    */
    public $_numSect	= 0;
    /**
    *	The current body objects in the document, ready for final assembly
    */
    public $_bodyObj		= array();
    /**
    * 	The current number of objects in the document
    */
    public $_numObj			= 0 ;
    /**
    *	Flag for creating a page break
    */
    public $_pageBreakBefore= 0 ;
    /**
    *	Multiplier and divisor for unit conversion in twips
    */
    public $_mulUnit;
    public $_divUnit;
    /**
    *	Header/Footer object counter and fkag
    */
    public $_numHFObj = 0;
    public $_HFObjId = 0;
    /**
    *	Header/Footer table
    */
    public $_HFObjTable = array();
    /**
    *	The XML string generated by the output method
    */
    public $_XMLstring = '<?xml version="1.0"?><?mso-application progid="Word.Document"?><w:wordDocument xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml" xmlns:o="urn:schemas-microsoft-com:office:office" xml:space="preserve" >';

    /**
    * class constructor
    * 	This will start a new document
    *	@param	=> paper format name ('A4', 'A5', 'LEGAL', ...) or array(width, height) in centimeters
    *	@param	=> orientation 'portrait' (default) or 'landscape'
    *	@param	=> comma separated list of fonts used in the document - the first listed is the default font
    *	@param	=> units to be used : 'twips' or 'inch' or 'cm'
    *
    *	Generate default page size, margins and orientation (default are used throughout the document if not changed through newSection method)
    *
    */
//TODO: This should be cleaned up to use the PHP5 style __construct
    public function CWordXML( $paper="A4", $orientation="portrait", $fonts='Arial', $unit='cm' ) {

        switch ( $unit ) {
            case 'twips' :
                    $this->_mulUnit = 1;
                    $this->_divUnit = 1;
                    $ind = 850;
                    break;
            case 'inch' :
                    $this->_mulUnit = 1440;
                    $this->_divUnit = 1;
                    $ind = 0.59;
                    break;
            case 'cm' :
            default :
                    $this->_mulUnit = 1440;
                    $this->_divUnit = 2.54;
                    $ind = 1.5;
                    break;
            }

        $this->_fonts = explode(',', $fonts);
        $this->_docPr = array(
                            'view'		=>	'print',
                            'percent'	=>	'100');
        // Initialize the sectPr Element with default values.
        $this->_sectPr[0] = array(
						'pgSz'	=>	$this->PRVTpgSzdecode( $paper, $orientation ),
						'pgMar'	=>	array(
										'top'		=>	1417,
										'right'		=>	1417,
										'bottom'	=>	1417,
										'left'		=>	1417,
										'header'	=>	0,
										'footer'	=>	0,
										'gutter'	=>	0
										),
						'hdr'	=>	array(),
						'ftr'	=>	array()
						);
	}

    /*
    *	Set the document properties (title, author, creation date, ...)
    *	@param	associative array of Word document properties, key are the document property element name such as
    *				'Title'		=> document title
    *				'Subject'		=> document subjec
    *				'Author'		=> name of the author
    *				'Description'	=> document description
    *				'Created'		=> creation date
    *				'Company'		=> name of the company
    *				'Keywords'		=> comma separated list of keywords
    *
    */
    public function setDocumentProperties( $properties ) {
        foreach ( $properties as $propName => $propValue ) {
            $this->_docProperties[$propName] = $propValue;
        }
    }

    /*
    *	Begin creation of a header/footer object
    *		Return object ID
    */
    public function startHFObj() {
        if ( $this->_HFObjId ) {
            die ("Nested Object is not allowed");
        }
        $this->_numHFObj++;
        $this->_HFObjId = $this->_numHFObj;
        $this->_HFObjTable[$this->_HFObjId] = array();
        return $this->_HFObjId;
    }

    /*
    *	Stop creation of a Header/Footer object
    */
    public function endHFObj() {
        $this->_HFObjId = 0;
    }

    /*
    *	Create a new section in the document
    *	@param		=> type of section ('next-page'(default), 'continuous', 'even-page', 'odd-page')
                        Note: 'next-column' is not supported
    *	@param		=> paper size
    *	@param		=> paper orientation 'portrait'(default) or 'landscape'
    *					Note: if $paper and/or $orientation are null, previous section values will apply (or default values set in CwordXML if first section)
    */
    public function newSection( $option="next-page", $paper=null, $orientation=null ) {
        $prevSect = $this->_numSect;
        if ( $this->_numSect != 0 || $this->_numObj != 0 ) {
        // Close previous section
            $this->_numObj++;
            $this->_bodyObj[$this->_numObj] = array();
            $this->_bodyObj[$this->_numObj]['type'] = 'section';
            $this->_bodyObj[$this->_numObj]['value'] = $this->_numSect;
            $this->_numSect++;
            $this->_sectPr[$this->_numSect] = array();
            $this->_sectPr[$this->_numSect]['pgSz'] = $this->_sectPr[$prevSect]['pgSz'];
            $this->_sectPr[$this->_numSect]['pgMar'] = $this->_sectPr[$prevSect]['pgMar'];
        }
        // Prepare next section : set page size and orientation
        $pgSz = $this->PRVTpgSzdecode( $paper, $orientation );
        if ( isset( $pgSz['height'] ) ) {
            $this->_sectPr[$this->_numSect]['pgSz']['height'] = $pgSz['height'];
            $this->_sectPr[$this->_numSect]['pgSz']['width'] = $pgSz['width'];
        }
        if ( isset( $pgSz['orientation'] ) ) {
            $this->_sectPr[$this->_numSect]['pgSz']['orientation'] = $pgSz['orientation'];
        }
        $this->_sectPr[$this->_numSect]['option'] = $option;
        $this->_sectPr[$this->_numSect]['hdr'] = array();
        $this->_sectPr[$this->_numSect]['ftr'] = array();
    }

    /*
    *	Add the header/footer object passed in param to the section
    *	@param		=> Object ID to be added
    *	@param		=> type : 'hdr' or 'ftr'
    *	@param		=> 'odd', 'even', 'first'
    *
    */
    public function addHFObj( $HFObjID, $type, $option='odd' ) {
        $this->_sectPr[$this->_numSect][$type][] = array( $HFObjID, $option );
        if ( $option == 'even' ) {
            $this->_docPr['evenAndOddHeaders'] = 1;
        }
    }

    /*
    *	Set current section page margins defined in the units set in CwordXML object constructor
    *	@param	top margin
    *	@param	bottom margin
    *	@param	left margin
    *	@param	right margin
    *	@param	header position
    *	@param	footer position
    *	@param	gutter margin
    *
    */
    public function setMargin( $top, $bottom, $left, $right, $header=0, $footer=0, $gutter=0) {
        $ratio = $this->_mulUnit/$this->_divUnit;
        $this->_sectPr[$this->_numSect]['pgMar']['top'] = round($top*$ratio);
        $this->_sectPr[$this->_numSect]['pgMar']['bottom'] =round($bottom*$ratio);
        $this->_sectPr[$this->_numSect]['pgMar']['left'] = round($left*$ratio);
        $this->_sectPr[$this->_numSect]['pgMar']['right'] = round($right*$ratio);
        $this->_sectPr[$this->_numSect]['pgMar']['header'] = round($header*$ratio);
        $this->_sectPr[$this->_numSect]['pgMar']['footer'] = round($footer*$ratio);
        $this->_sectPr[$this->_numSect]['pgMar']['gutter'] = round($gutter*$ratio);
    }

    /*
    *	Set pageBreakBefore flag (next body object will appear on a new page)
    */
    public function newPage() {
        $this->_pageBreakBefore = 1;
    }

    /*
    *	Include a table in the Word document at the current position
    *
    *	@param	=> two dimensional array of cell values
    *	@param	=> Style of the table content
    *	@param	=> column description array ( column width, column header (opt.), column cell alignment (opt), column cell text run options (opt.) )
    *	@param	=> associative array of options
    *				'width'		=> <number> which will specify the width of the table 0 = auto (default)
     *				'showBorders'	=>	0 = no line
    *								1 = outside line only
    *								2 = outside line and column lines
    *								3 = outside, row and column line (default)
    *				'borderColor' 	=> hexadecimal color value defining the colour of the lines, default, black.
    *				'outerborderType' => 'none' (same as 'showBorders' = 0), 'single' (default), 'thick', 'double', 'dotted', 'dashed' (outside line type)
    *				'innerborderType' => 'none' (same as 'showBorders' = 0), 'single' (default), 'thick', 'double', 'dotted', 'dashed' (row and coluln line type)
    *				'pos' 			=> 'left' (default) ,'right','center'
    *				'indent' 		=> the width the table should be indented by (numeric in selected unit)
    *				'showHeaders' 	=> 0 (default) =  no header, 1 = show headers once, 2 = repeat header at the top of every page
    *				'headerStyle'	=> style name for header cells
    *				'cellStyle' 		=> defined style name for content cells
    *				'rowGap' 		=> the space added at the top and bottom of each row, between the text and the lines (in pt)
    *				'colGap' 		=> the space on the left and right sides of each cell (in pt)
    *				'splitRows'		= >0 (default) or 1, whether or not to allow the rows to be split across page boundaries
    */
    public function addTable( $data, $tblStyle = '', $cols=array(), $options=array() ) {
        // Set table style and width
        $tbl = "<w:tbl>\n";
        $tbl .= "\t<w:tblPr>\n";
        if ( $tblStyle ) {
            $tbl .= "\t<w:tblStyle w:val=\"" . $tblStyle . "\" />\n";
        }
        if ( $options['width'] ) {
            $tbl .= "\t<w:tblW w:w=\"" . round(($options['width']*$this->_mulUnit/$this->_divUnit)) . "\" w:type=\"dxa\" />\n";
            $tbl .= "\t<w:tblLayout w:type=\"fixed\" />\n";
        } else {
            $tbl .= "\t<w:tblW w:w=\"0\" w:type=\"auto\" />\n";
        }
        // Set table borders
        $tbl .= "\t<w:tblBorders>\n";
        $showBorders = isset( $options['showBorders'] ) ? $options['showBorders'] : 0 ;
        $innerborderType = isset( $options['innerborderType'] ) ? $options['innerborderType'] : 'single' ;
        $outerborderType = isset( $options['outerborderType'] ) ? $options['outerborderType'] : 'single' ;
        $borderColor = isset( $options['borderColor'] ) ? $options['borderColor'] : '000000' ;
        switch ( $showBorders ) {
            case 0 :	$tbl .= "\t\t<w:top w:val=\"none\" />\n";
                        $tbl .= "\t\t<w:left w:val=\"none\" />\n";
                        $tbl .= "\t\t<w:bottom w:val=\"none\" />\n";
                        $tbl .= "\t\t<w:right w:val=\"none\" />\n";
                        $tbl .= "\t\t<w:insideH w:val=\"none\" />\n";
                        $tbl .= "\t\t<w:insideV w:val=\"none\" />\n";
                        break;
            case 1 :	$tbl .= "\t\t<w:top w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:left w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:bottom w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:right w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:insideH w:val=\"none\" />\n";
                        $tbl .= "\t\t<w:insideV w:val=\"none\" />\n";
                        break;
            case 2 :	$tbl .= "\t\t<w:top w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:left w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:bottom w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:right w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:insideH w:val=\"none\" />\n";
                        $tbl .= "\t\t<w:insideV w:val=\"$innerborderType\" w:color=\"$borderColor\" />\n";
                        break;
            case 3 :
            default:	$tbl .= "\t\t<w:top w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:left w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:bottom w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:right w:val=\"$outerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:insideH w:val=\"$innerborderType\" w:color=\"$borderColor\" />\n";
                        $tbl .= "\t\t<w:insideV w:val=\"$innerborderType\" w:color=\"$borderColor\" />\n";
                        break;
            }
        $tbl .= "\t</w:tblBorders>\n";
        // Cell margin (defined by rowGap and cellGap options) defatl = 3pt
        $rowGap = 20 * ( isset( $options['rowGap'] ) ? intval($options['rowGap']) : 3 ) ;
        $cellGap = 20 * ( isset( $options['cellGap'] ) ? intval($options['cellGap']) : 3 ) ;
        $tbl .= "\t<w:tblCellMar >\n";
        $tbl .= "\t\t<w:top w:w=\"" . $rowGap . "\" w:type=\"dxa\" />\n";
        $tbl .= "\t\t<w:left w:w=\"" . $cellGap . "\" w:type=\"dxa\" />\n";
        $tbl .= "\t\t<w:bottom w:w=\"" . $rowGap . "\" w:type=\"dxa\" />\n";
        $tbl .= "\t\t<w:right w:w=\"" . $cellGap . "\" w:type=\"dxa\" />\n";
        $tbl .= "\t</w:tblCellMar >\n";
        // Table alignment
        if ( isset($options['pos']) ) {
            switch ( $options['pos'] ) {
                case 'left'	:
                case 'right' :
                case 'center' :
                    $tbl .= "<w:tblpPr w:horzAnchor=\"margin\" w:tblpXSpec=\"" . $options['pos'] . "\" />\n";
                    break;
                default :
                    break;
            }
        }
        if ( isset($options['indent']) && is_numeric($options['indent']) ) {
            $tbl .= "<w:tblInd w:w=\"" . round(($options['indent']*$this->_mulUnit/$this->_divUnit)) . "\" w:type=\"dxa\" />\n";
        }
        $tbl .= "\t</w:tblPr>\n";
        //  Column width definition
        $tbl .= "\t<w:tblGrid>\n";
        foreach ( $cols as $c ) {
            $tbl .= "\t\t<w:gridCol w:w=\"" . round(($c[0]*$this->_mulUnit/$this->_divUnit)) . "\" />\n";
        }
        $tbl .= "\t</w:tblGrid>\n";
        // Create table cell properties, paragraph properties and  text run properties element for each row
        $tcPr = array();
        $pPr = array();
        $rPr = array();
        for ( $i= 0; $i<count($cols); $i++ ) {
            if ( $width = $cols[$i][0] ) {
                $t = "\t\t\t<w:tcPr>\n";
                $t .= "\t\t\t\t<w:tcW w:w=\"" . round(($width*$this->_mulUnit/$this->_divUnit)) . "\" />\n";
                $t .= "\t\t\t</w:tcPr>\n";
            }
            $tcPr[$i] = $t;
            $p = '';
            if ( isset( $options['cellStyle'] ) ) {
                $p .= "\t\t\t\t<w:pStyle w:val=\"" . $options['cellStyle'] . "\" />\n";
            }
            if ( $cols[$i][2] ) {
                $pOptions = $this->PRVTpPrOptdecode( $cols[$i][2] ) ;
                foreach ( $pOptions as $key => $val )
                $p .= "\t\t\t\t<w:$key w:val=\"$val\" />\n";
            }
            $pPr[$i] = $p ? "\t\t\t\t<w:pPr>\n" . $p . "\t\t\t\t</w:pPr>\n" : "" ;
            $r = '';
            if ( $cols[$i][3] ) {
                $r .= "<w:rPr>";
                $rOptions = $this->PRVTrPrOptdecode( $cols[$i][2] );
                foreach ( $rOptions as $key => $val ) {
                    $r .= "<w:".$key." w:val=\"".$val."\" />";
                }
                $r .= "</w:rPr>";
            }
            $rPr[$i] = $r;
        }
        // Show headers if showHeaders option is set
        if ( $options['showHeaders'] ) {
            $tbl .= "\t<w:tr>\n";
            $tbl .= "\t\t<w:trPr>\n";
            $val = $options['showHeaders'] == 2 ? "on" : "off";
            $tbl .= "\t\t\t<w:tblHeader w:val=\"" . $val . "\" />\n";
            $val = $options['splitRows'] ? "off" : "on" ;
            $tbl .= "\t\t\t<w:cantSplit w:val=\"" . $val . "\" />\n";
            $tbl .= "\t\t</w:trPr>\n";
            for ( $i=0; $i<count($cols); $i++ ) {
                $tbl .= "\t\t<w:tc>\n";
                $tbl .= $tcPr[$i];
                $tbl .= "\t\t\t<w:p>\n";
                if ( isset( $options['headerStyle'] ) ) {
                    // Apply header style
                    $tbl .= "\t\t\t\t<w:pPr>\n";
                    $tbl .= "\t\t\t\t<w:pStyle w:val=\"" . $options['headerStyle'] . "\" />\n";
                    $tbl .= "\t\t\t\t</w:pPr>\n";
                    $tbl .= "\t\t\t\t<w:r><w:t>" . $cols[$i][1] . "</w:t></w:r>\n";
                } else {
                    // Apply standard cell text run options
                    $tbl .= $pPr[$i];
                    $tbl .= "\t\t\t\t<w:r>" . $rPr[$i] ."<w:t>" . $cols[$i][1] . "</w:t></w:r>\n";
                    }
                $tbl .= "\t\t\t</w:p>\n";
                $tbl .= "\t\t</w:tc>\n";
            }
            $tbl .= "\t</w:tr>\n";
        }
        foreach ( $data as $row ) {
            $tbl .= "\t<w:tr>\n";
            $tbl .= "\t\t<w:trPr>\n";
            $val = $options['splitRows'] ? "off" : "on" ;
            $tbl .= "\t\t\t<w:cantSplit w:val=\"" . $val . "\" />\n";
            $tbl .= "\t\t</w:trPr>\n";
            for ( $i=0; $i<count($row); $i++ ) {
                $tbl .= "\t\t<w:tc>\n";
                $tbl .= $tcPr[$i];
                $tbl .= "\t\t\t<w:p>\n";
                $tbl .= $pPr[$i];
                $tbl .= "\t\t\t\t<w:r>" . $rPr[$i] . "<w:t>" . $row[$i] . "</w:t></w:r>\n";
                $tbl .= "\t\t\t</w:p>\n";
                $tbl .= "\t\t</w:tc>\n";
                }
            $tbl .= "\t</w:tr>\n";
        }
        $tbl .= "</w:tbl>\n";
        if ( $this->_HFObjId ) {
            $this->_HFObjTable[$this->_HFObjId][] = $tbl;
        } else {
            // Initialize new body object
            $this->_numObj++;
            $this->_bodyObj[$this->_numObj] = array();
            $this->_bodyObj[$this->_numObj]['type'] = 'table';
            $this->_bodyObj[$this->_numObj]['value'] = $tbl;
		}
	}

    /*
    *	Include a new paragraph in the document at the current position
    *
    *	@param	=> content of the paragraph 	either a single char string  or '{<field name>}'
    *								or an array of char string  or '{<field name>}'
    *	@param	=> style name of the paragraph
    *	@param	=> comma separated list of paragraph options :
    *				'pageBreakBefore'		=> start paragraph on a new page
    *				'keepLines'				=> prevent a page breaks in the paragraph
    *				'keepNext'				=> prevents a page break between this paragraph and the next
    *				'left', right', 'center', 'both'	=> paragraph alignment
    *	@param	=> comma separated list of text run options.
    *			Each text run option list will be applied to the corresponding string in $text array
    *				'b'/'-b','i'/'-i','u'	/'-u'	=> bold, italic, underlined
    *				'caps'/'-caps'		=> capital letters
    *				'tab'				=> insert one tab before text (can be repeated to insert several tabs)
    *
    */
    public function addText( $text, $style, $pOptions='', $rOptions=array() ) {

    // Generate pPr element
    $pPr .= "\t<w:pPr>\n";
    $pPr .= "\t\t<w:pStyle w:val=\"".$style."\" />\n";
    $pControl = $this->PRVTpPrOptdecode($pOptions);
    if ( $this->_pageBreakBefore ) {
        $pCOntrol['pageBreakBefore'] = 'on';
        $this->_pageBreakBefore = 0;
    }
    foreach ( $pControl as $key => $val ) {
        $this->_XMLstring .= "\t\t<w:$key w:val=\"$val\" />\n";
    }
    $pPr .= "\t</w:pPr>\n";
    // Generate text with consistent set of properties (runs)
    if ( !is_array($text) ) {
        $text = array( $text );
    }
    if ( !is_array($rOptions) && $rOptions ) {
        $rOptions = array( $rOptions );
    }
    $tab = '';
    for ( $i=0; $i<count($text); $i++ ) {
        $t =& $text[$i];
        $options = isset( $rOptions[$i] ) ? $this->PRVTrPrOptdecode( $rOptions[$i] ) : array() ;
        $r .= isset($options['tab']) ? str_repeat("<w:r><w:tab /></w:r>", $options['tab']) : "";
        $is_field = preg_match( "/\{([A-Z]+)\}/", $t, $instr );
        $r .= $is_field ? "<w:fldSimple w:instr=\"" . $instr[1] . " \\* MERGEFORMAT\" >" : "";
        $r .= "<w:r>";
        if ( count( $options ) ) {
            $r .= "<w:rPr>";
            foreach ( $options as $key => $val ) {
                $r .= $key != 'tab' ? "<w:".$key." w:val=\"".$val."\" />" : "";
            }
            $r .= "</w:rPr>";
        }
        $r .=  $is_field ? "<w:t></w:t></w:r></w:fldSimple>" : "<w:t>" . str_replace( "&amp;#10;", "</w:t><w:br w:type=\"text-wrapping\" /><w:t>", $t ) . "</w:t></w:r>";
    }
    $txt = "<w:p>\n" . $pPr . $r . "</w:p>\n";
        if ( $this->_HFObjId ) {
            $this->_HFObjTable[$this->_HFObjId][] = $txt;
        } else {
            $this->_numObj++;
            $this->_bodyObj[$this->_numObj] = array();
            $this->_bodyObj[$this->_numObj]['type'] = 'paragraph';
            $this->_bodyObj[$this->_numObj]['value'] = $txt;
        }
    }

    /*
    *	Create a user-defined style
    *	@param	name of the new style
    *	@param	name of an existing style on which the new style is based
    *	@param	Style options array :
    *			'pControl'		=> comma separated list of controls : keepLines, keepNext, pageBreakBefore, alignment options
    *			'indent' 		=> array( <left>, <right>, <hanging>, <first-line>) values in centimeters
    *			'spacing' 		=> array( <before>, <after>) values in pt
    *			'tabs' 		=> array( [<val>:<pos>]+), where val= 'left', 'right', 'center' and <pos> in centimeters
    *			'rPr' 			=> array( <font-name>, <size>, <options>, <color>)  where options is a comma separated list of options in
    *				 			b/-b -> bold/not bold
    *				 			i/-i -> italic/not italic
    *							u/-u -> underlined/not underlined
    *				 			caps/-caps -> capitalized/ not capitalized
    *			'listPr' 		=> array( <ilfo>, <ilvl>)
    Note : ilfo should not be 0 but any integer > 0
    *	param	$default=true if default style
    */
    public function addStyle( $styleName, $basedOn, $options=array(), $default=false ) {
        $styleDef=array();
        $styleDef['type']='paragraph';
        $styleDef['basedOn']=$basedOn;
        if ( $default ) {
            foreach ( $this->_styles as $style ) {
                $style['default'] = 'off';
            }
            $styleDef['default'] = 'on';
        } else {
            $styleDef['default'] = 'off';
        }
        $styleDef['pControl'] = $this->PRVTpPrOptdecode( $options['pControl'] ) ;
        $styleDef['indent'] = array();
        if ( is_array($options['indent']) ) {
            foreach( $options['indent'] as $val ) {
                $styleDef['indent'][] = is_numeric($val) ? round($val*$this->_mulUnit/$this->_divUnit) : 0;
            }
        }
        $styleDef['spacing'] = array();
        if ( is_array($options['spacing']) ) {
            foreach( $options['spacing'] as $val ) {
                $styleDef['spacing'][] = is_numeric($val) ? round($val*20) : 120;
            }
        }
        $styleDef['tabs'] = $this->PRVTtabsdecode( $options['tabs'] );
        $styleDef['rPr'] = array();
        if ( is_array($options['rPr']) ) {
            $styleDef['rPr'][0]=$options['rPr'][0] ? $options['rPr'][0] : '';
            $styleDef['rPr'][1]=is_numeric($options['rPr'][1]) ? round(2*$options['rPr'][1]) : 22;
            $opt = $this->PRVTrPrOptdecode( $options['rPr'][2] );
            $s = '' ;
            foreach ( $opt as $key => $val ) {
                if ( $val == 'on' ) {
                    $s .= $s? ','.$key : $key;
                } else {
                    $s .= $s? ',-'.$key : '-'.$key;
                }
            }
            $styleDef['rPr'][2]= $s;
        }
        $styleDef['listPr'] = array();
        if ( is_array($options['listPr']) ) {
            $styleDef['listPr']=$options['listPr'];
        }
        $this->_styles[$styleName] = $styleDef;
    }

    /*
    *	Create a user-defined list definition
    *
    *	@param	list definition ID (numeric)
    *	@param	list type ('Mulitlevel', 'singleLevel', 'HybridMultilevel')
    *	@param	list instanciation (numeric)
    *	@param	array of level definition
    *			'start'		=>	first index in the list
    *			'style'		=>	paragraph style
    *			'lvltext'		=>	text level (in the form of '%1.' or '%1.%2' for paragraph numbering)
    *			'lvljust'		=>	justification ('left', 'right', ...)
    *			'lvlrPr'		=>	array( <font>, <size>, <options>, <hexa color value>)
    *			'tabs'			=>	array( <tabDef>) where  tabDef= <position>:<value>
    *			'indent'		=>	array( <left>, <right>, <hanging>, <first-line>) values in centimeters
    *
    *	If the list definition ID already exists in thelistDef table it will be replaced by the new list definition
    */
    public function addList( $listDefId, $type, $ilfo, $lvlDef ) {
        $listDef = array();
        $listDef['type'] = $type;
        $listDef['ilfo'] = $ilfo;
        $listDef['lvl'] = array();
        foreach ( $lvlDef as $lvl => $def ) {
            $arr = array();
            $arr['start'] = is_numeric($def['start']) ? $def['start'] : 1;
            $arr['style'] = $def['style'];
            $arr['lvltext'] = $def['lvltext'];
            $arr['lvljust'] = $def['lvljust'];
            if ( is_array( $def['lvlrPr'] ) ) {
                $rPr =& $def['lvlrPr'];
                $arr['lvlrPr'][0] = isset($rPr[0]) ? $rPr[0] : "" ;
                $arr['lvlrPr'][1] = isset($rPr[1]) && is_numeric($rPr[1]) ? 2*$rPr[1] : 22 ;
                $rOpt = $this->PRVTrPrOptdecode( $rPr[2] ) ;
                $r = '';
                foreach ( $rOpt as $key => $val ) {
                    $r .= ( $r ? ',' : '' ) . ( $val == 'off' ? '-' : '' ) . $val ;
                }
                $arr['lvlrPr'][2] = $r ;
                $arr['lvlrPr'][3] = isset($rPr[3]) ? $rPr[3] : "" ;
            }
            $arr['tabs'] = $this->PRVTtabsdecode( $def['tabs'] );
            $arr['indent'] = array();
            if ( is_array($def['indent']) ) {
                foreach( $def['indent'] as $val ) {
                    $arr['indent'][] = is_numeric($val) ? round($val*$this->_mulUnit/$this->_divUnit) : 0;
                }
            } else {
                $arr['indent'] = array( 0, 0, 0, 0 );
            }
            $listDef['lvl'][$lvl] = $arr;
        }
        $this->_listDef[$listDefId] = $listDef;
    }

    /*
    *	Generate the XML file
    *	@param	fname of the file to be generated (if not defined the XML string is returned)
    */
    public function output( $filename='' ) {
        // Generate fonts tag
        $this->_XMLstring .= "\n<w:fonts>\n";
        $this->_XMLstring .= "<w:defaultFonts w:ascii=\"".$this->_fonts[0]."\" w:fareast=\"".$this->_fonts[0]."\" w:h-ansi=\"".$this->_fonts[0]."\" w:cs=\"".$this->_fonts[0]."\"/>\n";
        for ($i=1; $i<count($this->_fonts); $i++ ) {
            $this->_XMLstring .= "<w:font w:name=\"". $this->_fonts[$i] . "\" />\n";
        }
        $this->_XMLstring .= "</w:fonts>\n";
        // Generate listDef tag
        if ( count( $this->_listDef ) ) {
            $this->_XMLstring .= "<w:lists>\n";
            foreach( $this->_listDef as $listID => $list ) {
                $this->_XMLstring .= "\t<w:listDef w:listDefId=\"". $listID . "\">\n";
                $this->_XMLstring .= "\t\t<w:plt w:val=\"".$list['type']."\"/>\n";
                foreach ( $list['lvl'] as $lvl => $def ) {
                    $this->_XMLstring .= "\t\t<w:lvl w:ilvl=\"". $lvl . "\" >\n";
                    $this->_XMLstring .= "\t\t\t<w:start w:val=\"" . $def['start'] . "\"/>\n";
                    $this->_XMLstring .= "\t\t\t<w:pStyle w:val=\"" . $def['style'] . "\"/>\n";
                    $this->_XMLstring .= "\t\t\t<w:lvlText w:val=\"" . $def['lvltext'] . "\"/>\n";
                    $this->_XMLstring .= "\t\t\t<w:lvlJc w:val=\"" . $def['lvljust'] . "\"/>\n";
                    $this->_XMLstring .= "\t\t\t<w:pPr>\n";
                    if ( count($def['tabs']) ) {
                        $this->_XMLstring .= $this->PRVTsetTabs( $def['tabs'] );
                    }
                    $this->_XMLstring .= "\t\t\t\t<w:ind w:left=\"" . $def['indent'][0] . "\" w:right=\"" . $def['indent'][1] . "\" w:hanging=\"" . $def['indent'][2] . "\" w:first_line=\"" . $def['indent'][3] ."\" />\n";
                    $this->_XMLstring .= "\t\t\t</w:pPr>\n";
                    if ( isset($def['lvlrPr']) ) {
                        $this->_XMLstring .= $this->PRVTsetrPr( $def['lvlrPr'] );
                    }
                    $this->_XMLstring .= "\t\t</w:lvl>\n";
                }
                $this->_XMLstring .= "\t</w:listDef>\n";
            }
            foreach ( $this->_listDef as $listID => $list ) {
                $this->_XMLstring .= "\t<w:list w:ilfo=\"" . $list['ilfo'] ."\"><w:ilst w:val=\"" . $listID ."\"/></w:list>\n";
            }
            $this->_XMLstring .= "</w:lists>\n";
        }

        // Generate styles element
        $this->_XMLstring .= "<w:styles>\n";
        foreach ( $this->_styles as $styleName => $def ) {
            $this->_XMLstring .= "\t<w:style w:type=\"" . $def['type'] . "\" w:styleID=\"$styleName\" w:default=\"" . $def['default'] . "\" >\n";
            $this->_XMLstring .= "\t\t<w:name w:val=\"$styleName\" />\n";
            $this->_XMLstring .= "\t\t<w:basedOn w:val=\"" . $def['basedOn'] . "\" />\n";
            $p = '';
            if ( $pControl = $def['pControl'] ) {
                foreach ( $pControl as $key => $val ) {
                    $p .= "\t\t\t<w:$key w:val=\"$val\" />\n";
                }
            }
            if ( list( $before, $after ) = $def['spacing'] ) {
                $p .= "\t\t\t<w:spacing w:before=\"$before\" w:after=\"$after\" />\n";
            }
            if ( list( $left, $right, $hanging, $first_line ) = $def['indent'] ) {
                $p .= "\t\t\t<w:ind w:left=\"$left\" w:right=\"$right\" w:hanging=\"$hanging\" w:first_line=\"$first_line\" />\n";
            }
            if ( list( $ilfo, $ilvl ) = $def['listPr'] ) {
                $p .= "\t\t\t<w:listPr>\n";
                $p .= "\t\t\t\t<w:ilfo w:val=\"$ilfo\" />\n";
                $p .= "\t\t\t\t<w:ilvl w:val=\"$ilvl\" />\n";
                $p .= "\t\t\t</w:listPr>\n";
            }
            if ( count($def['tabs']) ) {
                $p .= $this->PRVTsetTabs( $def['tabs'] );
            }
            if ( count($def['rPr']) ) {
                $p .= $this->PRVTsetrPr($def['rPr']);
            }
            $this->_XMLstring .= $p ? "\t\t<w:pPr>\n" . $p . "\t\t</w:pPr>\n" : "";
            $this->_XMLstring .= "\t</w:style>\n";
        }
        $this->_XMLstring .= "</w:styles>\n";

        // Generate DocumentProperties element
        if ( count($this->_docProperties) ) {
            $this->_XMLstring .= "<o:DocumentProperties>\n";
            foreach ( $this->_docProperties as $key => $val ) {
                $this->_XMLstring .= "\t<o:" . $key . ">" . $val . "</o:" . $key . ">\n";
            }
            $this->_XMLstring .= "</o:DocumentProperties>\n";
        }

        // Generate docPr element
        $this->_XMLstring .= "<w:docPr>\n";
        $this->_XMLstring .= "\t<w:view w:val=\"" . $this->_docPr['view'] . "\"/>\n";
        $this->_XMLstring .= "\t<w:zoom w:percent=\"" . $this->_docPr['percent'] . "\"/>\n";
        if ( isset( $this->_docPr['evenAndOddHeaders'] ) ) {
            $this->_XMLstring .= "\t<w:evenAndOddHeaders />\n";
        }
        $this->_XMLstring .= "</w:docPr>\n";

        // Generate body element
        $sect_num = 0;
        $this->_XMLstring .= "<w:body>\n";

        foreach ( $this->_bodyObj as $obj ) {
            switch ( $obj['type'] ) {
                case 'paragraph' :
                case 'table'	 :
                    $this->_XMLstring .= $obj['value'];
                    break;
                case 'section'	 :
                    $sectPr =& $this->_sectPr[$sect_num];
                    $this->_XMLstring .= "<w:p>\n" ;
                    $this->_XMLstring .= "<w:pPr>\n" ;
                    $this->_XMLstring .= $this->PRVTsetSectPr( $sectPr );
                    $this->_XMLstring .= "</w:pPr>\n" ;
                    $this->_XMLstring .= "</w:p>\n" ;
                    $sect_num++;
                    break;
                default			 :
                    break;
            }
        }

        // Generate last sectPr element
        $sectPr =& $this->_sectPr[$sect_num];
        $this->_XMLstring .= $this->PRVTsetSectPr( $sectPr );
        // End XML string
        $this->_XMLstring .= "</w:body>\n";
        $this->_XMLstring .= "</w:wordDocument>\n";
        // Return XML string
        if ( ! $filename ) {
            return $this->_XMLstring ;
        }
        // Create file
        if ( ! $f = fopen( $filename, 'wb' ) ) {
            return $AppUI->_('Cannot open file' );
        }
        if ( fwrite( $f, $this->_XMLstring ) === false ) {
            return $AppUI->_('Cannot write file' );
        }
        fclose( $f );
        return true;
    }

    /**
    *	Include default List ans Styles definition
    *		Multilevel list definition
    *		Normal style
    *		Title styles (3 levels)
    *
    */
    public function CWordDefault() {

        $this->addList( 1, 'Multilevel', 1, array( 0 => array( 	'start'			=> 1,
                                                                'style'			=> 'CW_Title1',
                                                                'lvltext'		=> '%1.',
                                                                'lvljust'		=> 'left',
                                                                'indent'		=> array( $ind, 0, $ind, 0)
                                                            ),
                                                   1 => array(	'start'			=> 1,
                                                                'style'			=> 'CW_Title2',
                                                                'lvltext'		=> '%1.%2.',
                                                                'lvljust'		=> 'left',
                                                                'indent'		=> array( $ind, 0, $ind, 0)
                                                            ),
                                                   2 => array(	'start'			=> 1,
                                                                'style'			=> 'CW_Title3',
                                                                'lvltext'		=> '%1.%2.%3.',
                                                                'lvljust'		=> 'left',
                                                                'indent'		=> array( $ind, 0, $ind, 0)
                                                            ) ) );
        // Ex_Normal, Ex_List, Ex_Title1, Ex_Title2, Ex_Title3
        $this->addStyle( 'CW_Normal', null, array(	'pControl' 		=> '',
                                                    'justification'	=> 'both',
                                                    'indent'		=> array($ind, 0, 0, 0),
                                                    'spacing'		=> array( 0, 6),
                                                    'tabs'			=> array(),
                                                    'rPr'			=> array( 'Arial', 11, ''),
                                                    'listPr'		=> array()
                                                    )
                                    , true );
        $this->addStyle( 'CW_Title1', 'CW_Normal', array(	'pControl'		=> 'keepLines,keepNext,pageBreakBefore',
                                                            'justification'	=> 'left',
                                                            'indent'		=> array( $ind, 0, $ind, 0 ),
                                                            'spacing'		=> array( 24, 18 ),
                                                            'tabs'			=> array( 'left:1.5' ),
                                                            'rPr'			=> array( 'Arial', 16, 'b' ),
                                                            'listPr'		=> array( 1, 0 )
                                                        ) );
        $this->addStyle( 'CW_Title2', 'CW_Title1', array(	'pControl'		=> '-pageBreakBefore,keepLines,keepNext',
                                                            'rPr'			=> array( 'Arial', 14, 'b'),
                                                            'listPr'		=> array( 1, 1)
                                                        ) );
        $this->addStyle( 'CW_Title3', 'CW_Title1', array(	'pControl'		=> '-pageBreakBefore,keepLines,keepNext',
                                                            'rPr'			=> array( 'Arial', 11, 'b,i'),
                                                            'listPr'		=> array( 1, 2 )
                                                        ) );
	}

    /*
    *	Utility function : decode a list of run parameters (bold, italic, underlined, capitalized)
    *	@param	list of parameters as a comma separated list of options
    */
    public function PRVTrPrOptdecode( $options ) {
        $out = array();
        $opt = explode( ',', $options );
        foreach ( $opt as $o )
            switch (trim($o)) {
                case 'b'	:	$out['b']='on';
                                break;
                case '-b'	:	$out['b']='off';
                                break;
                case 'i'	:	$out['i']='on';
                                break;
                case '-i'	:	$out['i']='off';
                                break;
                case 'u'	:	$out['u']='on';
                                break;
                case '-u'	:	$out['u']='off';
                                break;
                case 'caps'	:	$out['caps']='on';
                                break;
                case '-caps':	$out['caps']='off';
                                break;
                case 'tab'	:	$out['tab']= isset( $out['tab'] ) ? $out['tab']+1 : 1;
                default		:	break;
                }
        return $out ;
	}

    /*
    *	Utility function : decode a list of paragraph parameters (breakBeforePage, keepNext, keepLines, alignment)
    *	@param	list of parameters as a comma separated list of options
    */
    public function PRVTpPrOptdecode( $options ) {
        $out = array();
        $opt = explode( ',', $options );
        foreach ( $opt as $o ) {
            switch (trim($o)) {
                case 'breakBeforePage'	:	$out['breakBeforePage']='on';
                                            break;
                case '-breakBeforePage'	:	$out['breakBeforePage']='off';
                                            break;
                case 'keepNext'	:			$out['keepNext']='on';
                                            break;
                case '-keepNext'	:		$out['keepNext']='off';
                                            break;
                case 'keepLines'	:		$out['keepLines']='on';
                                            break;
                case '-keepLines'	:		$out['keepLines']='off';
                                            break;
                case 'right'	:
                case 'left'		:
                case 'center'	:
                case 'both'		:			$out['jc'] = trim($o) ;
                                            break;
                default		:				break;
            }
        }
        return $out ;
	}

    /*
    *	Utility function : decode an array of tab definition
    *	@param	array  of tabs definition format = array(  '<align>:<position>' )
    */
    public function PRVTtabsdecode( $tabs ) {

        $out = array();
        if ( is_array($tabs) ) {
            foreach( $tabs as $tab ) {
                $nc = strpos($tab, ':');
                $align = substr( $tab, 0, $nc);
                $nc++;
                $pos = substr($tab, $nc);
                if ( in_array( $align, array('left', 'right', 'center') ) && is_numeric($pos) ) {
                    $pos = round($pos*$this->_mulUnit/$this->_divUnit);
                    $out[] = $align . ':' . $pos;
                }
            }
        }
        return $out;
	}

    /*
    *	Utility function : format Tab Element from an array of tabs definition
    *	@param	array of tabs definition
    */
    public function PRVTsetTabs ( $tabs ) {

        $out = "\t\t\t<w:tabs>\n";
        foreach( $tabs as $tab ) {
            $nc = strpos( $tab, ':' );
            $val = substr( $tab, 0, $nc);
            $nc++;
            $pos = substr( $tab, $nc);
            $out .= "\t\t\t\t<w:tab w:val=\"$val\" w:pos=\"$pos\" />\n";
        }
        $out .= "\t\t\t</w:tabs>\n";
        return $out ;
    }

    /*
    *	Utility function : format text run Properties (rPr element) from an array of text run properties
    *	@param	array of text run properties = array( '<font>', <size>, '<list of options>', <hexa color value> )
    */
    public function PRVTsetrPr ( $rPr ) {
        $out .= "\t\t\t<w:rPr>\n";
        list ( $font, $size, $options, $color ) = $rPr;
        if ( $font ) {
            $out .= "\t\t\t\t<w:rFonts w:ascii=\"$font\" />\n";
        }
        if ( $size ) {
            $out .= "\t\t\t\t<w:sz w:val=\"$size\" />\n";
        }
        $opt = $this->PRVTrPrOptdecode( $options );
        foreach( $opt as $key => $val ) {
            $out .= "\t\t\t\t<w:$key w:val=\"$val\" />\n";
        }
        if ( $color ) {
            $out .= "\t\t\t\t<w:color w:val=\"$color\" />\n";
        }
        $out .= "\t\t\t</w:rPr>\n";
        return $out;
    }

    /*
    *	Utility function : decode the list of page size parameters and convert to twips
    *	@param	standard paper size ('A4', 'LETTER', etc.) or array( width, height)
    *	@param	'portrait' or 'landscape'
    */
    public function PRVTpgSzdecode ( $paper, $orientation ) {

        $out = array();
        if ( isset($paper) ) {
            if ( is_array($paper) ){
                if ( count($paper) >= 2 ) {
                    $out['width'] = round(intval($paper[0])*$this->_mulUnit/$this->_divUnit) ;
                    $out['height'] = round(intval($paper[1])*$this->_mulUnit/$this->_divUnit) ;
                } else {
                    $out['width']= 11906;
                    $out['height']= 16838;
                }
            } else {
                switch (strtoupper($paper)) {
                    case 'A3':	$out['width']= 16838;
                                $out['height']= 23811;
                                break ;
                    case 'A4':
                    default:	$out['width']= 11906;
                                $out['height']= 16838;
                                break ;
                    case 'A5':	$out['width']= 8391;
                                $out['height']= 11906;
                                break ;
                    case 'LETTER':
                                $out['width']= 12240;
                                $out['height']= 15840;
                                break ;
                    case 'LEGAL':
                                $out['width']= 12240;
                                $out['height']= 20160;
                                break ;
                    case 'EXECUTIVE':
                                $out['width']= 10437;
                                $out['height']= 15120;
                                break ;
                    case 'FOLIO':
                                $out['width']= 12240;
                                $out['height']= 18720;
                                break ;
                }
            }
        }
        if ( isset($orientation) && isset($paper) ) {
            if (strtolower($orientation) == 'landscape') {
                $a=$out['width'];
                $out['width']=$out['height'];
                $out['height']=$a;
            }
        }
        return $out;
    }

    /*
    *	Utility function : format header/footer description within the current sectPr element
    *	@param	type of element ('hdr' or 'ftr')
    *	@param	array of object IDs to be included in the element
    */
    public function PRVTsetHdrFtr ( $element, $HFdef ) {
        global $titlePg;

        $out = "";
        if ( count($HFdef) == 0 ) { // This is required otherwise, for obscure reason, Word will generate the same hdr/ftr as previous section
            $out .= "\t<w:" . $element . " w:type=\"odd\" >\n";
            $out .= "\t<w:p />\n";
            $out .= "\t</w:" . $element . " >\n";
        } else {
            foreach ( $HFdef as $def ) {
                list ( $HFObjId, $type ) = $def ;
                $out .= "\t<w:" . $element . " w:type=\"" . $type . "\" >\n";
                foreach ( $this->_HFObjTable[$HFObjId] as $txt ) {
                    $out .= $txt ;
                }
                $out .= "\t</w:" . $element . " >\n";
                if ( $type == "first" ) {
                    $titlePg = 1;
                }
            }
        }
        return $out;
    }

    /*
    *	Utility function : format a sectPr element
    *	@param	sectPr definition array
    *	@param	section number
    */
    public function PRVTsetSectPr ( $sectPr ) {
        global $titlePg;

        $out = "";
        $titlePg = 0;
        $out .= "<w:sectPr>\n" ;
        $out .= "<w:type w:val=\"" . $sectPr['option'] . "\" />\n" ;
        $out .= "\t<w:pgSz w:w=\"" . $sectPr['pgSz']['width'] . "\" w:h=\"" . $sectPr['pgSz']['height'] . "\" w:orient=\"" .  $sectPr['pgSz']['orientation'] . "\" />\n";
        $out .= "\t<w:pgMar w:top=\"" . $sectPr['pgMar']['top'] . "\" w:right=\"" . $sectPr['pgMar']['right'] . "\" w:bottom=\"" . $sectPr['pgMar']['bottom'] . "\" w:left=\"" . $sectPr['pgMar']['left'] . "\" w:header=\"" . $sectPr['pgMar']['header'] . "\" w:footer=\"" . $sectPr['pgMar']['footer'] . "\" w:gutter=\"" . $sectPr['pgMar']['gutter'] . "\" />\n";
        $out .= $this->PRVTsetHdrFtr( 'hdr', $sectPr['hdr'] );
        $out .= $this->PRVTsetHdrFtr( 'ftr', $sectPr['ftr'] );
        if ( $titlePg ) {
            $out .= "\t<w:titlePg />\n";
        }
        $out .= "</w:sectPr>\n" ;
        return $out;
    }
}